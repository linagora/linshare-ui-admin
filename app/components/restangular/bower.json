{
  "name": "restangular",
  "version": "1.0.4",
  "main": "./dist/restangular.min.js",
  "description": "Restfull Resources service for AngularJS apps",
  "repository": {
    "type": "git",
    "url": "git://github.com/mgonto/restangular"
  },
  "dependencies": {
    "lodash": "~1.2.0",
    "angular": "*"
  },
  "ignore": [
    "node_modules",
    "components",
    "lib"
  ],
  "gitHead": "c4da4a59e3e209852717302e6e7d5a82d3a88f2c",
  "readme": "#Restangular\n\n[![Build Status](https://travis-ci.org/mgonto/restangular.png)](https://travis-ci.org/mgonto/restangular)\n\n\nRestangular is an AngularJS service that will help you get, delete and update Restfull Resources with very few lines in the Client side. \nThis service is a perfect fit for any WebApp that uses Restfull Resources as the API for your application.\n\n**If you want to check a live example, [please click this link to plunkr](http://plnkr.co/edit/d6yDka?p=preview).** It's the same example as [Angular's Javascript Projects](http://angularjs.org/#wire-up-a-backend) but Restangularized.\n\n## Differences with $resource\n\nRestangular has several features that distinguish it from $resource:\n\n* **It uses promises**. Instead of doing the \"magic\" filling of objects like $resource, it uses promises.\n* **You can use this in $routeProvider.resolve**. As Restangular returns promises, you can return any of the methods in the `$routeProvider.resolve` and you'll get the real object injected into your controller if you want.\n* **It doesn't have all those `$resource` bugs**. Restangular doesn't have problem with trailling slashes, additional `:` in the URL, escapaing information, expecting only arrays for getting lists, etc.\n* **It supports all HTTP methods**.\n* **You don't have to create one $resource object per request**. Each time you want to do a request, you can just do it using the object that was returned by Restangular. You don't need to create a new object for this.\n* **You don't have to write or remember ANY URL**. With $resource, you need to write the URL Template. In here, you don't write any urls. You just write the name of the resource you want to fetch and that's it.\n* **It supports nested RestFUL resources**. If you have Nested RestFUL resources, Restangular can handle them for you. You don't have to know the URL, the path, or anything to do all of the HTTP operations you want.\n* **Restangular lets you create your own methods**. You can create your own methods to run the operation that you want. The sky is the limit.\n* **Support for wrapped responses**. If your response for a list of element actually returns an object with some property inside which has the list, it's very hard to use $resource. Restangular knows that and it makes it easy on you. Check out https://github.com/mgonto/restangular#my-response-is-actually-wrapped-with-some-metadata-how-do-i-get-the-data-in-that-case\n* **You can build your own URLs with Restangular objects easily**. Restangular lets you create a Restangular object for any url you want with a really nice builder.\n\nLet's see a quick and short example of this features\n````javascript\n// It uses promises.\nRestangular.one('users').getList().then(function(users) {\n  $scope.user = users[0];\n})\n\n// Later in the code.\n\n// Requests /users/123/cars You don't have to know the URL. Just the name of the resource\n// This is a promise\n$scope.cars = $scope.user.getList('cars');\n\n// POST /users/123/sendMessage You've creat.ed your own method with the path & operation that you wanted\n$scope.user.sendMessage();\n\n// URL Building\n// GET to /user/123/messages/123/from/123/unread\n$scope.user.one('message', 123).one('from', 123).getList('unread')\n\n\n````\n\n#How do I add this to my project?\n\nYou can download this by:\n\n* Using bower and running `bower install restangular`\n* Using npm and running `npm install restangular`\n* Downloading it manually by clicking [here to download development unminified version](https://raw.github.com/mgonto/restangular/master/dist/restangular.js) or [here to download minified production version](https://raw.github.com/mgonto/restangular/master/dist/restangular.min.js)\n* Using [JsDelivr CDN files](https://github.com/jimaek/jsdelivr/tree/master/files/restangular):\n\n````html\n<!-- Use LATEST folder to always get the latest version-->\n<script type=\"text/javascript\" src=\"http://cdn.jsdelivr.net/restangular/latest/restangular.js\"></script>\n<script type=\"text/javascript\" src=\"http://cdn.jsdelivr.net/restangular/latest/restangular.min.js\"></script>\n\n<!-- Or use TAG number for specific version -->\n<script type=\"text/javascript\" src=\"http://cdn.jsdelivr.net/restangular/0.6.1/restangular.js\"></script>\n<script type=\"text/javascript\" src=\"http://cdn.jsdelivr.net/restangular/0.6.1/restangular.min.js\"></script>\n````\n\n\n#Dependencies\n\nRestangular depends on Angular and (Underscore or Lodash). **angular-resource is no longer needed, now this uses `$http` instead of `$resource*`*\n\n#Starter Guide\n\n## Quick configuration for Lazy Readers\nThis is the quick configuration to bootstrap all. Read the rest of the documentation for further configuration and understanding\n\n````javascript\nangular.module('sample-app', ['restangular'])\n  .config(function(RestangularProvider) {\n    RestangularProvider.setBaseUrl(\"/api/v1\");\n  });\n  \nangular.module('sample-app').controller('MainCtrl', function($scope, Restangular) {\n  $scope.projects = Restangular.all('projects').getList();\n});\n````\n\n## Adding dependency to Restangular module in your app\n\nThe first thing you need to do after adding link to script file, is mentioning in your app that you'll use Restangular.\n\n````javascript\nvar app = angular.module('angularjs-starter', ['restangular']);\n````\n\n## Using Restangular\n\nNow that you have everything configured, you can just inject this Service to any Controller or Directive like any other :)\n\n### Creating Main Restangular object\n\nThere're 2 ways of creating a main Restangular object. \nThe first one and most common one is by stating the main route of all requests. \nThe second one is by stating the main route and object of all requests.\n\n````javascript\n// Only stating main route\nRestangular.all('accounts')\n\n// Stating main object\nRestangular.one('accounts', 1234)\n````\n\n### Let's code!\n\nNow that we have our main Object lets's start playing with it.\n\n````javascript\n// First way of creating a Restangular object. Just saying the base URL\nvar baseAccounts = Restangular.all('accounts');\n\n// This will query /accounts and return a promise. As Angular supports setting promises to scope variables\n// as soon as we get the information from the server, it will be shown in our template :)\n$scope.allAccounts = baseAccounts.getList();\n\nvar newAccount = {name: \"Gonto's account\"};\n\n// POST /accounts\nbaseAccounts.post(newAccount);\n\n//You can do RequestLess \"connections\" if you need as well\n\n// Just ONE GET to /accounts/123/buildings/456\nRestangular.one('accounts', 123).one('buildings', 456).get()\n\n// Just ONE GET to /accounts/123/buildings\nRestangular.one('accounts', 123).getList('buildings')\n\n//Here we use Promises then \n// GET /accounts\nbaseAccounts.getList().then(function (accounts) {\n  // Here we can continue fetching the tree :).\n\n  var firstAccount = accounts[0];\n  // This will query /accounts/123/buildings considering 123 is the id of the firstAccount\n  $scope.buildings = firstAccount.getList(\"buildings\");\n  \n  // GET /accounts/123/places?query=param with request header: x-user:mgonto\n  $scope.loggedInPlaces = firstAccount.getList(\"places\", {query: param}, {'x-user': 'mgonto'})\n\n  // This is a regular JS object, we can change anything we want :) \n  firstAccount.name = \"Gonto\"\n  \n  //If we wanted to keep the original as it's we can copy it to a new element\n  var editFirstAccount = Restangular.copy(firstAccount);\n  editFirstAccount.name = \"New Name\";\n  \n\n  // PUT /accounts/123. The name of this account will be changed from now on\n  firstAccount.put();\n  editFirstAccount.put();\n\n  // DELETE /accounts/123 We don't have first account anymore :(\n  firstAccount.remove();\n  \n  var myBuilding = {\n    name: \"Gonto's Building\",\n    place: \"Argentina\"\n  };\n  \n  // POST /accounts/123/buildings with MyBuilding information\n  firstAccount.post(\"Buildings\", myBuilding).then(function() {\n    console.log(\"Object saved OK\");\n  }, function() {\n    console.log(\"There was an error saving\");\n  });\n\n  // GET /accounts/123/users?query=params\n  firstAccount.getList(\"users\", {query: params}).then(function(users) {\n    // Instead of posting nested element, a collection can post to itself\n    // POST /accounts/123/users\n    users.post({userName: 'unknown'});\n    \n    // Custom methods are available now :).\n    // GET /accounts/123/users/messages?param=myParam\n    users.customGET(\"messages\", {param: \"myParam\"})\n    \n    var firstUser = users[0];\n\n    // GET /accounts/123/users/456. Just in case we want to update one user :)\n    $scope.userFromServer = firstUser.get();\n    \n    // ALL http methods are available :)\n    // HEAD /accounts/123/users/456\n    firstUser.head()\n\n  });\n\n}, function errorCallback() {\n  alert(\"Oops error from server :(\");\n})\n\n// Second way of creating Restangular object. URL and ID :)\nvar account = Restangular.one(\"accounts\", 123);\n\n// GET /accounts/123?single=true\n$scope.account = account.get({single: true});\n\n// POST /accounts/123/messages?param=myParam with the body of name: \"My Message\"\naccount.customPOST(\"messages\", {param: \"myParam\"}, {}, {name: \"My Message\"})\n\n\n````\n\n## Configuring Restangular\n\n### Properties\nRestangular comes with defaults for all of it's properties but you can configure them. **So, if you don't need to configure something, there's no need to add the configuration.**\nYou can set all this configurations in **`RestangularProvider` or `Restangular` service to change the global configuration** or you can **use the withConfig method in Restangular service to create a new Restangular service with some scoped configuration**. Check the section on this later.\n\n#### baseUrl\nThe base URL for all calls to your API. For example if your URL for fetching accounts is http://example.com/api/v1/accounts, then your baseUrl is `/api/v1`. The default baseUrl is an empty string which resolves to the same url that AngularJS is running, so you can also set an absolute url like `http://api.example.com/api/v1` if you need do set another domain.\n\n#### extraFields\nThis are the fields that you want to save from your parent resources if you need to display them. By default this is an Empty Array which will suit most cases\n\n#### defaultHttpFields\n`$http` from AngularJS can receive a bunch of parameters like `cache`, `transformRequest` and so on. You can set all of those properties in the object sent on this setter so that they will be used in EVERY API call made by Restangular. This is very useful for caching for example. All properties that can be set can be checked here: http://docs.angularjs.org/api/ng.$http#Parameters\n\n#### urlCreator\nThis is the factory that will create URLs based on the resources. For the time being, only Path UrlCreator is implemented. This means that if you have a resource names Building which is a child of Account, the URL to fetch this will be `/accounts/123/buildings`. In the future, I'll implement more UrlCreator like QueryParams UrlCreator.\n\n#### addElementTransformer\nThis is a hook. After each element has been \"restangularized\" (Added the new methods from Restangular), the corresponding transformer will be called if it fits. \n\nThis should be used to add your own methods / functions to entities of certain types.\n\nYou can add as many element transformers as you want. The signature of this method can be one of the following:\n\n* **addElementTransformer(route, transformer)**: Transformer is called with all elements that have been restangularized, no matter if they're collections or not.\n\n* **addElementTransformer(route, isCollection, transformer)**: Transformer is called with all elements that have been restangularized and match the specification regarding if it's a collection or not (true | false)\n\n\n#### onElemRestangularized\nThis is a hook. After each element has been \"restangularized\" (Added the new methods from Restangular), this will be called. It means that if you receive a list of objects in one call, this method will be called first for the collection and then for each element of the collection.\n\n**I favor the usage of `addElementTransformer` instead of `onElemRestangularized` whenever possible as the implementation is much cleaner.**\n\n\nThis callback is a function that has 3 parameters:\n\n* **elem**: The element that has just been restangularized. Can be a collection or a single element.\n* **isCollection**: Boolean indicating if this is a collection or a single element.\n* **what**: The model that is being modified. This is the \"path\" of this resource. For example `buildings`\n* **Restangular**: The instanced service to use any of its methods\n \nThis can be used together with `addRestangularMethod` (Explained later) to add custom methods to an element\n\n\n#### responseInterceptor (or responseExtractor. It's an Alias)\nThe responseInterceptor is called after we get each response from the server. It's a function that receives 4 arguments:\n\n* **response**: The response got from the server\n* **operation**: The operation made. It'll be the HTTP method used except for a `GET` which returns a list of element which will return `getList` so that you can distinguish them.\n* **what**: The model that's being requested. It can be for example: `accounts`, `buildings`, etc.\n* **url**: The relative URL being requested. For example: `/api/v1/accounts/123`\n\nSome of the use cases of the responseInterceptor are handling wrapped responses and enhancing response elements with more methods among others.\n\n#### requestInterceptor\nThe requestInterceptor is called before sending any data to the server. It's a function that must return the element to be requested. This function receives the following arguments:\n\n* **element**: The element to send to the server.\n* **operation**: The operation made. It'll be the HTTP method used except for a `GET` which returns a list of element which will return `getList` so that you can distinguish them.\n* **what**: The model that's being requested. It can be for example: `accounts`, `buildings`, etc.\n* **url**: The relative URL being requested. For example: `/api/v1/accounts/123`\n\n#### fullRequestInterceptor\nThe fullRequestInterceptor is similar to the `requestInterceptor` but more powerful. It lets you change the element, the request parameters and the headers as well.\n\nIt's a function that receives the same as the `requestInterceptor` plus the headers and the query parameters (in that order).\n\nIt must return an object with the following properties:\n* **headers**: The headers to send\n* **params**: The request parameters to send\n* **element**: The element to send\n\n#### errorInterceptor\nThe errorInterceptor is called whenever there's an error. It's a function that receives the response as a parameter.\n\n#### listTypeIsArray\n\nWe don't use `$resource` anymore so this property is depracated. I've left it with an empty setter per now to avoid errors, but it'll be removed in the future.\n\n~~You can set in this property wether the `getList` method will return an Array or not. Most of the times, it will return an array, as it returns a collection of values. However, sometimes this method returns first some metadata and inside it has the array. So this can be used together with `responseExtractor` to get the real array. The default value is true.~~\n\n#### restangularFields\n\nRestangular required 3 fields for every \"Restangularized\" element. This are:\n\n* id: Id of the element. Default: id\n* route: Name of the route of this element. Default: route\n* parentResource: The reference to the parent resource. Default: parentResource\n* restangularCollection: A boolean indicating if this is a collection or an element. Default: restangularCollection\n\nAll of this fields except for `id` are handled by Restangular, so most of the time you won't change them. You can configure the name of the property that will be binded to all of this fields by setting restangularFields property.\n\n#### methodOverriders\n\nYou can now Override HTTP Methods. You can set here the array of methods to override. All those methods will be sent as POST and Restangular will add an X-HTTP-Method-Override header with the real HTTP method we wanted to do.\n\n#### defaultRequestParams\n\nYou can set default Query parameters to be sent with every request\n\n#### fullResponse\n\nYou can set fullResponse to true to get the whole response every time you do any request. The full response has the restangularized data in the `data` field, and also has the headers and config sent. By default, it's set to false.\n\n#### defaultHeaders\n\nYou can set default Headers to be sent with every request.\n\n#### requestSuffix\n\nIf all of your requests require to send some suffix to work, you can set it here. For example, if you need to send the format like `/users/123.json`you can add that `.json` to the suffix using the `setRequestSuffix`method\n\n### How to configure them globally\n\nYou can do this configurations in either the `config` or the `run` method. If your configurations don't need any other services, then I'd recommend you do them in the `config`. If your configurations depend on other services, you can configure them in the `run` using `Restangular` instead of `RestangularProvider` \n\n#### Configuring in the `config`\n````javascript\napp.config(function(RestangularProvider) {\n    RestangularProvider.setBaseUrl('/api/v1');\n    RestangularProvider.setExtraFields(['name']);\n    RestangularProvider.setResponseExtractor(function(response, operation) {\n        return response.data;\n    });\n    \n    RestangularProvider.addElementTransformer('accounts', false, function(elem) {\n       elem.accountName = 'Changed';\n       return elem;\n    });\n    \n    RestangularProvider.setDefaultHttpFields({cache: true});\n    RestangularProvider.setMethodOverriders([\"put\", \"patch\"]);\n    \n    // In this case we configure that the id of each element will be the _id field and we change the Restangular route. We leave the default value for parentResource\n    RestangularProvider.setRestangularFields({\n      id: \"_id\",\n      route: \"restangularRoute\"\n    });\n    \n    RestangularProvider.setRequestSuffix('.json');\n    \n    // Use Request interceptor\n    RestangularProvider.setRequestInterceptor(function(element, operation, route, url) {\n      delete elem.name;\n      return elem;\n    });\n    \n    // Or full request interceptor, its powerfull brother\n    RestangularProvider.setFullRequestInterceptor(function(element, operation, route, url, headers, params) {\n      delete elem.name;      \n      return {\n        element: elem,\n        params: _.extend(params, {single: true}),\n        headers: headers\n      };\n    });\n    \n});\n\n````\n\n#### Configuring in the `run`\n\n````javascript\n// Here I inject the service BaseUrlCalculator which I need\napp.run(function(Restangular, BaseUrlCalculator) {\n    Restangular.setBaseUrl(BaseUrlCalculator.calculate());\n});\n````\n\n### How to create a Restangular service with a different configuration from the global one\nLet's assume that for most requests you need some configuration (The global one), and for just a bunch of methods you need another configuration. In that case, you'll need to create another Restangular service with this particular configuration. This scoped configuration will inherit all defaults from the global one. Let's see how.\n\n````javascript\n// Global configuration\napp.config(function(RestangularProvider) {\n  RestangularProvider.setBaseUrl('http://www.google.com');\n  RestangularProvider.setRequestSuffix('.json');\n});\n\n//Restangular service that uses Bing\napp.factory('BingRestangular', function(Restangular) {\n  return Restangular.withConfig(function(RestangularConfigurer) {\n    RestangularConfigurer.setBaseUrl('http://www.bing.com');\n  });\n});\n\n// Let's use them from a controller\napp.controller('MainCtrl', function(Restangular, BingRestangular) {\n  \n  // GET to http://www.google.com/users.json\n  // Uses global configuration\n  Restangular.all('users').getList()\n  \n  // GET to http://www.bing.com/users.json\n  // Uses Bing configuration which is based on Global one, therefore .json is added.\n  BingRestangular.all('users').getList()\n});\n````\n\n## Methods description\n\nThere're 3 sets of methods. Collections have some methods and elements have others. There're are also some common methods for all of them\n\n### Restangular methods\nThis are the methods that can be called in the Restangular object.\n* **one(route, id)**: This will create a new Restangular object that is just a pointer to one element with the route `route` and the specified id.\n* **all(route)**: This will create a new Restangular object that is just a pointer to a list of elements for the specified path.\n* **copy(fromElement)**: This will create a copy of the from element so that we can modified the copied one.\n* **restangularizeElement(parent, element, route)**: Restangularizes a new element\n* **restangularizeCollection(parent, element, route)**: Restangularizes a new collection\n\n### Element methods\n* **get([queryParams, headers])**: Gets the element. Query params and headers are optionals\n* **getList(subElement, [queryParams, headers])**: Gets a nested resource. subElement is mandatory. **It's a string with the name of the nested resource (and URL)**. For example `buildings`\n* **put([queryParams, headers])**: Does a put to the current element\n* **post(subElement, elementToPost, [queryParams, headers])**: Does a POST and creates a subElement. Subelement is mandatory and is the nested resource. Element to post is the object to post to the server\n* **remove([queryParams, headers])**: Does a DELETE\n* **head([queryParams, headers])**: Does a HEAD\n* **trace([queryParams, headers])**: Does a TRACE\n* **options([queryParams, headers])**: Does a OPTIONS\n* **patch([queryParams, headers])**: Does a PATCH\n* **one(route, id)**: Used for RequestLess connections and URL Building. See section below.\n* **all(route)**: Used for RequestLess connections and URL Building. See section below.\n* **getRestangularUrl()**: Gets the URL of the current object.\n\n### Collection methods\n* **getList([queryParams, headers]): Gets itself again (Remember this is a collection)**.\n* **post(elementToPost, [queryParams, headers])**: Creates a new element of this collection.\n* **head([queryParams, headers])**: Does a HEAD\n* **trace: ([queryParams, headers])**: Does a TRACE\n* **options: ([queryParams, headers])**: Does a OPTIONS\n* **patch([queryParams, headers])**: Does a PATCH\n* **putElement(idx, params, headers)**: Puts the element on the required index and returns a promise of the updated new array\n* **getRestangularUrl()**: Gets the URL of the current object.\n* **one(route, id)**: Used for RequestLess connections and URL Building. See section below.\n* **all(route)**: Used for RequestLess connections and URL Building. See section below.\n\n### Custom methods\n* **customGET(path, [params, headers])**: Does a GET to the specific path. Optionally you can set params and headers.\n* **customGETLIST(path, [params, headers])**: Does a GET to the specific path. **In this case, you expect to get an array, not a single element**. Optionally you can set params and headers.\n* **customDELETE(path, [params, headers])**: Does a DELETE to the specific path. Optionally you can set params and headers.\n* **customPOST(path, [params, headers, elem])**: Does a POST to the specific path. Optionally you can set params and headers and elem. Elem is the element to post. If it's not set, it's assumed that it's the element itself from which you're calling this function.\n* **customPUT(path, [params, headers, elem])**: Does a PUT to the specific path. Optionally you can set params and headers and elem. Elem is the element to post. If it's not set, it's assumed that it's the element itself from which you're calling this function.\n* **customOperation(operation, path, [params, headers, elem])**: This does a custom operation to the path that we specify. This method is actually used from all the others in this subsection. Operation can be one of: get, post, put, delete, head, options, patch, trace\n* **addRestangularMethod(name, operation, [path, params, headers, elem])**: This will add a new restangular method to this object with the name `name` to the operation and path specified (or current path otherwise). There's a section on how to do this later. \n\n \nLet's see an example of this:\n\n````javascript\n//GET /accounts/123/messages\nRestangular.one(\"accounts\", 123).customGET(\"messages\")\n\n//GET /accounts/messages?param=param2\nRestangular.all(\"accounts\").customGET(\"messages\", {param: \"param2\"})\n````\n## Copying elements\nBefore modifying an object, we sometimes want to copy it and then modify the copied object. We can't use `angular.copy` for this because it'll not change the `this` binded in the functions we add to the object. In this cases, you must use `Restangular.copy(fromElement)`.\n\n## Enhanced promises\n\nRestangular uses enhanced promises when returning. What does this mean? All promises returned now have 2 additional methods and collection promises have 3. This are the methods:\n\n* **call(methodName, params*)**: This will return a new promise of the previous value, after calling the method called methodName with the parameters params.\n* **get(fieldName)**: This will return a new promise for the type of the field. The param of this new promise is the property `fieldName` from the original promise result.\n* **push(object)**: This method will only be in the promises of arrays. It's a sub set of the call method that does a push.\n \nI know this explanations are quite complicated, so let's see an example :D.\n\n````javascript\nvar buildings = Restangular.all(\"buildings\").getList();\n\n// New promise after adding the new building\n// Now you can show in scope this newBuildings promise and it'll show all the buildings \n// received from server plus the new one added\nvar newBuildings = buildings.push({name: \"gonto\"});\n\nvar newBuildingsSame = buildings.call(\"push\", {name: \"gonto\"});\n\n// This is a promise of a number value. You can show it in the UI\nvar lengthPromise = buildings.get(\"length\");\n\nlengthPromise.then(function(length) {\n  // Here the length is the real length value of the returned collection of buildings\n});\n````\n\n## URL Building\nSometimes, we have a lot of entities names with their ids and we just want to fetch the later entity. In those cases, doing a request for everything to get the last entity is an overkill. For those cases, I've added the possibility to create URLs using the same API as creating a new Restangular object. This connections are created without doing any request. Let's see how to do this:\n\n````javascript\n\nvar restangualrSpaces = Restangular.one(\"accounts\",123).one(\"buildings\", 456).all(\"spaces\");\n\n// This will do ONE get to /accounts/123/buildings/456/spaces\nrestangularSpaces.getList()\n\n// This will do ONE get to /accounts/123/buildings/456/spaces/789\nRestangular.one(\"accounts\", 123).one(\"buildings\", 456).one(\"spaces\", 789).get()\n\n// POST /accounts/123/buildings/456/spaces\nRestangular.one(\"accounts\", 123).one(\"buildings\", 456).all(\"spaces\").post({name: \"New Space\"});\n\n// DELETE /accounts/123/buildings/456\nRestangular.one(\"accounts\", 123).one(\"buildings\", 456).remove();\n````\n\n## Creating new Restangular Methods\n\nLet's assume that your API needs some custom methods to work. If that's the case, always calling customGET or customPOST for that method with all parameters is a pain in the ass. That's why every element has a `addRestangularMethod` method. \n\nThis can be used together with the hook `addElementTransformer` to do some neat stuff. Let's see an example to learn this:\n\n````javascript\n//In your app configuration (config method)\n\n// It will transform all building elements, NOT collections\nRestangularProvider.addElementTransformer('buildings', false, function(building) {\n        // This will add a method called evaluate that will do a get to path evaluate with NO default\n        // query params and with some default header\n        // signature is (name, operation, path, params, headers, elementToPost)\n        \n        building.addRestangularMethod('evaluate', 'get', 'evaluate', undefined, {'myHeader': 'value'});\n});\n\nRestangularProvider.addElementTransformer('users', true, function(users) {\n        // This will add a method called evaluate that will do a get to path evaluate with NO default\n        // query params and with some default header\n        // signature is (name, operation, path, params, headers, elementToPost)\n        \n        users.addRestangularMethod('login', 'post', 'login');\n});\n\n// Then, later in your code you can do the following:\n\n//GET to /buildings/123/evaluate?myParam=param with headers myHeader: value\n//Signature for this \"custom created\" methods is (params, headers, elem)\n// If something is set to any of this variables, the default set in the method creation will be overrided\n// If nothing is set, then the defaults are sent\nRestangular.one('building', 123).evaluate({myParam: 'param'});\n\n//GET to /buildings/123/evaluate?myParam=param with headers myHeader: specialHeaderCase\nRestangular.one('building', 123).evaluate({myParam: 'param'}, {'myHeader': 'specialHeaderCase'});\n\nRestangular.all('users').login();\n\n\n\n````\n \n# FAQ\n\n#### **How can I handle errors?**\n\nErrors can be checked on the second argument of the then.\n\n````javascript\nRestangular.all(\"accounts\").getList().then(function() {\n  console.log(\"All ok\");\n}, function(response) {\n  console.log(\"Error with status code\", response.status);\n});\n````\n\n#### **I need to send one header in EVERY Restangular request, how do I do this?**\n\nYou can use `defaultHeaders` property for this or `$httpProvider.defaults.headers`, whichever suits you better. `defaultsHeaders` can be scoped with `withConfig` so it's really cool.\n\n#### Can I cache requests?\n\n`$http` can cache requests if you send the property `cache` to true. You can do that for every Restangular request by using `defaultHttpFields` property. This is the way:\n\n````javascript\nRestangularProvider.setDefaultHttpFields({cache: true});\n````\n\n#### Can it be used in `$routeProvider.resolve`?\n\nYes, of course. Every method in Restangular returns a promise so this can be used without any problem.\n\n#### **My response is actually wrapped with some metadata. How do I get the data in that case?**\n\nSo, let's assume that your data is the following:\n\n````javascript\n // When getting the list, this is the response.\n{\n  \"status\":\"success\",\n  \"data\": {\n    \"data\": [{\n      \"id\":1,\n      // More data\n    }],\n    \"meta\": {\n      \"totalRecord\":100\n    }\n  }\n}\n\n// When getting a single element, this is the response.\n{\n  \"status\":\"success\",\n  \"data\": {\n    \"id\" : 1\n    // More data\n  }\n}\n````\n\nIn this case, you'd need to configure Restangular's `responseExtractor`and `listTypeIsArray`. See the following:\n\n````javascript\napp.config(function(RestangularProvider) {\n    \n    // Now let's configure the response extractor for each request\n    RestangularProvider.setResponseExtractor(function(response, operation, what, url) {\n      // This is a get for a list\n      var newResponse;\n      if (operation === \"getList\") {\n        // Here we're returning an Array which has one special property metadata with our extra information\n        newResponse = response.data.data;\n        newResponse.metadata = response.data.meta;\n      } else {\n        // This is an element\n        newResponse = response.data;\n      }\n      return newResponse;\n    });\n});\n````\n\n#### **I use Mongo and the ID of the elements is `_id` not `id` as the default. Therefore requests are sent to undefined routes**\n\nWhat you need to do is to configure the `RestangularFields` and set the `id` field to `_id`. Let's see how:\n\n````javascript\nRestangularProvider.setRestangularFields({\n  id: \"_id\"\n});\n````\n\n\n#### **How do I handle CRUD operations in a List returned by Restangular?**\n\nThe best option for doing CRUD operations with a list, is to actually use the \"real\" list, and not the promise. It makes it easy to interact with it.\n\nLet's see an example :).\n\n````javascript\n// Here we use then to resolve the promise.\nRestangular.all('users').getList().then(function(users) {\n  $scope.users = users;\n  var userWithId = _.find(users, function(user) {\n    return user.id === 123;\n  });\n\n  userWithId.name = \"Gonto\";\n  userWithId.put();\n  \n  // ALternatively delete element from list when finished\n  userWithId.remove().then(function() {\n    // Updating the list and removing the user after the response is OK.\n    $scope.users = _.without($scope.users, userWithId);\n  });\n\n});\n````\n\nWhen you actually get some list by doing\n\n````javascript\n$scope.owners = house.getList('owners')\n````\n\nYou're actually assigning a Promise to the owners value of the $scope. As Angular knows how to process promises, if in your view you do an ng-repeat of this $scope variable, results will be shown once the promise is resolved (Response arrived).\nHowever, changes to that promise that you do from your HTML won't be seen in the scope, as it's not a real array. It's just a promise of an array.\n\n#### When I set baseUrl with a port, it's stripped out.\n\nIt won't be stripped out anymore as I've ditched `$resource` :). Now you can happily put the port :).\n\n#### Why does this depend on Lodash / Underscore?\n\nThis is a very good question. I could've done the code so that I don't depend on Underscore nor Lodash, but I think both libraries make your life SO much easier. They have all of the \"functional\" stuff like map, reduce, filter, find, etc. \nWith these libraries, you always work with immutable stuff, you get compatibility for browsers which don't implement ECMA5 nor some of these cool methods, and they're actually quicker.\nSo, why not use it? If you've never heard of them, by using Restangular, you could start using them. Trust me, you're never going to give them up after this!\n\n\n# Supported Angular's version\n\nRestangular supports both 1.0.X and 1.1.X up to versions 1.0.7 and 1.1.5.\n\nAlso, when using Restangular with version >= 1.1.4, in case you're using Restangular inside a callback not handled by Angular, you've to wrap this all request with a `$scope.apply` to make it work or you need to run one extra `$digest` manually. Check out https://github.com/mgonto/restangular/issues/71\n\n\n# Server Frameworks\n\nThis server frameworks play real nice with Restangular, as they let you create a Nested Restful Resources API easily:\n\n* Ruby on Rails\n* CakePHP for PHP\n* Play1 & 2 for Java & scala\n* Restify and Express for NodeJS\n* Tastypie for Django \n\n\n# Releases Notes\n\n[Click here to see Releases Notes](https://github.com/mgonto/restangular/blob/master/CHANGELOG.md)\n\n# License\n\nThe MIT License\n\nCopyright (c) 2013 Martin Gontovnikas http://www.gon.to/\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n",
  "readmeFilename": "README.md",
  "_id": "restangular@1.0.4"
}